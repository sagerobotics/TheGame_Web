<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Space Invaders — Mini Clone</title>
  <style>
    :root{
      --bg:#041326;
      --panel:#071829;
      --accent:#7bd389;
      --muted:#9fb7c8;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--muted); font-family:Inter,Segoe UI,Helvetica,Arial,sans-serif;}
    .wrap{display:flex; align-items:center; justify-content:center; height:100%;}
    .gamecard{width:900px; max-width:96vw; background:linear-gradient(180deg,#051423 0%, #071829 100%); border-radius:12px; padding:12px; box-shadow:0 10px 30px rgba(0,0,0,0.6);}
    .topbar{display:flex; justify-content:space-between; gap:12px; align-items:center; margin-bottom:8px;}
    .hud{display:flex; gap:12px; align-items:center;}
    .pill{background:rgba(255,255,255,0.03); padding:6px 12px; border-radius:999px; color:var(--muted); font-weight:600;}
    canvas{display:block; width:100%; background: radial-gradient(circle at 50% 0%, rgba(255,255,255,0.02), transparent 30%), linear-gradient(180deg,#02131b 0%, #041326 100%); border-radius:8px;}
    .center{display:flex; gap:8px; align-items:center; justify-content:center; margin-top:8px;}
    button{background:var(--accent); border:none; color:#03201a; padding:8px 14px; border-radius:8px; font-weight:700; cursor:pointer;}
    .muted{color:#6c8b9a; font-size:14px;}
    .overlay{position:absolute; top:0; left:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center; pointer-events:none;}
    .panel{pointer-events:auto; background:rgba(0,0,0,0.6); padding:18px 24px; border-radius:10px; text-align:center;}
    h1{margin:0 0 8px 0; font-size:20px; color:var(--accent);}
    p{margin:6px 0; color:var(--muted);}
    @media (max-width:640px){ .gamecard{padding:8px;} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="gamecard" id="gameCard">
      <div class="topbar">
        <div class="hud">
          <div class="pill">Score: <span id="score">0</span></div>
          <div class="pill">Lives: <span id="lives">3</span></div>
          <div class="pill">Level: <span id="level">1</span></div>
        </div>
        <div class="hud muted">← A / → D to move • Space to fire • R to restart</div>
      </div>

      <div style="position:relative;">
        <canvas id="canvas" width="800" height="520"></canvas>

        <!-- overlays for messages -->
        <div class="overlay" id="overlay" style="display:none;">
          <div class="panel" id="overlayPanel">
            <h1 id="overlayTitle">Paused</h1>
            <p id="overlayMsg">Press Space to start</p>
            <div style="margin-top:12px;">
              <button id="overlayBtn">Resume</button>
            </div>
          </div>
        </div>
      </div>

      <div class="center" style="margin-top:10px;">
        <button id="startBtn">Start Game</button>
        <button id="toggleSound">Toggle Sound</button>
      </div>
    </div>
  </div>

  <script>
  // -----------------------------
  // Space Invaders - single-file
  // -----------------------------

  // Canvas setup
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // HUD elements
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const levelEl = document.getElementById('level');
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayMsg = document.getElementById('overlayMsg');
  const overlayBtn = document.getElementById('overlayBtn');
  const startBtn = document.getElementById('startBtn');
  const toggleSoundBtn = document.getElementById('toggleSound');

  // Game state
  let lastTime = 0;
  let playing = false;
  let paused = true;
  let score = 0;
  let lives = 3;
  let level = 1;

  // Sound toggles (basic using Audio)
  let soundOn = true;
  const sfx = {
    shoot: new Audio(),
    hit: new Audio(),
    die: new Audio(),
    invaderMove: new Audio()
  };
  // Simple beep sounds using data URIs are omitted - you can load your own here:
  // sfx.shoot.src = 'shoot.wav'; // if you have sounds

  // Player
  const player = {
    w: 44,
    h: 20,
    x: canvas.width / 2 - 22,
    y: canvas.height - 60,
    speed: 320,
    canFire: true,
    fireCooldown: 320 // ms
  };

  // Bullets
  const bullets = []; // player's bullets
  const enemyBullets = [];

  // Invaders grid
  let invaders = [];
  const invaderColsBase = 10;
  const invaderRowsBase = 4;
  let invaderSpeed = 28; // horizontal pixels per second base
  let invaderDirection = 1; // 1 right, -1 left
  let invaderDescendAmount = 24;
  let invaderMoveTimer = 0;
  let invaderMoveInterval = 800; // ms between movements — decreases with level

  // Input
  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.key] = true;
    // prevent arrow key scrolling
    if (['ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    if (e.key === 'r' || e.key === 'R') restartGame();
    if (e.key === 'p' || e.key === 'P') togglePause();
  });
  window.addEventListener('keyup', e => { keys[e.key] = false; });

  // Utilities
  function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }

  // Initialize invaders for given level
  function createInvadersForLevel(lv){
    const cols = Math.max(6, invaderColsBase - Math.floor((lv-1)/2)); // gradually shrink columns
    const rows = Math.min(6, invaderRowsBase + Math.floor((lv-1)/2)); // gradually increase rows
    invaders = [];
    const marginX = 60;
    const marginY = 40;
    const spacingX = 54;
    const spacingY = 44;
    const startX = (canvas.width - (cols-1)*spacingX)/2;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        invaders.push({
          x: startX + c*spacingX,
          y: marginY + r*spacingY,
          w: 34,
          h: 22,
          row: r, col: c,
          alive: true,
          anim: 0
        });
      }
    }
    // tuning
    invaderDirection = 1;
    invaderMoveInterval = Math.max(160, 800 - (lv-1)*80); // faster each level
    invaderSpeed = 1; // horizontal step in pixels during movement tick
  }

  // Start or restart
  function startGame(){
    score = 0;
    lives = 3;
    level = 1;
    player.x = canvas.width/2 - player.w/2;
    bullets.length = 0;
    enemyBullets.length = 0;
    createInvadersForLevel(level);
    playing = true;
    paused = false;
    overlay.style.display = 'none';
    lastTime = performance.now();
    requestAnimationFrame(loop);
    updateHUD();
  }
  function restartGame(){
    startGame();
  }

  // Pause toggle
  function togglePause(){
    paused = !paused;
    overlay.style.display = paused ? 'flex' : 'none';
    overlayTitle.textContent = paused ? 'Paused' : '';
    overlayMsg.textContent = paused ? 'Press Resume or Space to continue' : '';
    overlayBtn.textContent = paused ? 'Resume' : 'Pause';
    if(!paused) {
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }
  }

  // HUD
  function updateHUD(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    levelEl.textContent = level;
  }

  // Spawn player bullet
  function playerFire(){
    if(!player.canFire) return;
    const now = performance.now();
    player.canFire = false;
    setTimeout(()=> player.canFire = true, player.fireCooldown);
    const bx = player.x + player.w/2 - 3;
    const by = player.y - 8;
    bullets.push({x:bx,y:by,w:6,h:14, speed: 520});
    if(soundOn && sfx.shoot.src) sfx.shoot.play();
  }

  // Spawn enemy bullet from a random alive invader in lowest row in a column
  function enemyFire(){
    // pick a random column that has alive invader(s)
    const alive = invaders.filter(i => i.alive);
    if(!alive.length) return;
    // restrict fire chance by level/time
    if(Math.random() > Math.min(0.35, 0.02 + level * 0.02)) return;
    const shooter = alive[randInt(0, alive.length - 1)];
    const bx = shooter.x + shooter.w/2 - 4;
    const by = shooter.y + shooter.h + 6;
    enemyBullets.push({x:bx,y:by,w:8,h:12, speed: 220 + level*30});
  }

  // Collision helpers
  function rectsCollide(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // Main loop
  function loop(now){
    if(paused || !playing) return;
    const dt = Math.min(40, now - lastTime) / 1000; // seconds (cap delta)
    update(dt);
    render();
    lastTime = now;
    requestAnimationFrame(loop);
  }

  // Update game state
  function update(dt){
    // Player input
    if(keys.ArrowLeft || keys.a || keys.A) player.x -= player.speed * dt;
    if(keys.ArrowRight || keys.d || keys.D) player.x += player.speed * dt;
    if(keys[' '] || keys.Spacebar) {
      // Allow firing with space
      if(!keys._spaceLock){
        playerFire();
        keys._spaceLock = true;
      }
    } else {
      keys._spaceLock = false;
    }

    // Bound player
    player.x = Math.max(8, Math.min(canvas.width - player.w - 8, player.x));

    // Move invaders (discrete tick style)
    invaderMoveTimer += dt*1000;
    if(invaderMoveTimer >= invaderMoveInterval){
      // Determine if any invader hits edge
      let hitEdge = false;
      for(const inv of invaders){
        if(!inv.alive) continue;
        const nextX = inv.x + invaderDirection * invaderSpeed * 12; // step multiplier for visible movement
        if(nextX < 10 || nextX + inv.w > canvas.width - 10){
          hitEdge = true;
          break;
        }
      }

      if(hitEdge){
        // descend and flip direction
        for(const inv of invaders){ if(inv.alive) inv.y += invaderDescendAmount; }
        invaderDirection *= -1;
      } else {
        for(const inv of invaders){ if(inv.alive) inv.x += invaderDirection * invaderSpeed * 12; }
      }

      // animate invaders
      for(const inv of invaders){ inv.anim = (inv.anim + 1) % 2; }

      // attempt enemy fire
      enemyFire();

      invaderMoveTimer = 0;
      if(soundOn && sfx.invaderMove.src) sfx.invaderMove.play();
    }

    // Update bullets
    for(let i = bullets.length-1;i>=0;i--){
      bullets[i].y -= bullets[i].speed * dt;
      if(bullets[i].y + bullets[i].h < 0) bullets.splice(i,1);
    }
    for(let i = enemyBullets.length-1;i>=0;i--){
      enemyBullets[i].y += enemyBullets[i].speed * dt;
      if(enemyBullets[i].y > canvas.height) enemyBullets.splice(i,1);
    }

    // Bullet vs invader collisions
    for(let b = bullets.length-1;b>=0;b--){
      let hit = false;
      for(let j = 0;j<invaders.length;j++){
        const inv = invaders[j];
        if(!inv.alive) continue;
        if(rectsCollide(bullets[b], inv)){
          inv.alive = false;
          bullets.splice(b,1);
          hit = true;
          score += 10;
          if(soundOn && sfx.hit.src) sfx.hit.play();
          break;
        }
      }
      if(hit) updateHUD();
    }

    // Enemy bullets vs player
    for(let i = enemyBullets.length-1;i>=0;i--){
      if(rectsCollide(enemyBullets[i], {x:player.x, y:player.y, w:player.w, h:player.h})){
        enemyBullets.splice(i,1);
        lives--;
        if(soundOn && sfx.die.src) sfx.die.play();
        if(lives <= 0){
          gameOver();
          return;
        }
        updateHUD();
      }
    }

    // Invader reach player or bottom
    for(const inv of invaders){
      if(!inv.alive) continue;
      if(inv.y + inv.h >= player.y - 6){
        // invaded
        gameOver();
        return;
      }
    }

    // Win check: all invaders dead -> next level
    if(invaders.every(i => !i.alive)){
      nextLevel();
    }
  }

  function nextLevel(){
    level++;
    bullets.length = 0;
    enemyBullets.length = 0;
    createInvadersForLevel(level);
    // small bonus and speed increase
    score += 100;
    updateHUD();
  }

  function gameOver(){
    playing = false;
    paused = true;
    overlay.style.display = 'flex';
    overlayTitle.textContent = 'Game Over';
    overlayMsg.textContent = `Final Score: ${score}. Press Restart to play again.`;
    overlayBtn.textContent = 'Restart';
  }

  // Render game
  function render(){
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // stars background
    drawStars();

    // draw player (a simple ship)
    drawPlayer();

    // draw invaders
    drawInvaders();

    // draw bullets
    ctx.fillStyle = '#fff';
    for(const b of bullets) ctx.fillRect(b.x, b.y, b.w, b.h);
    ctx.fillStyle = '#f55';
    for(const b of enemyBullets) ctx.fillRect(b.x, b.y, b.w, b.h);

    // Draw ground / barrier line
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(0, canvas.height - 48, canvas.width, 2);
  }

  // Visual helpers
  function drawPlayer(){
    // body
    const x = player.x, y = player.y, w = player.w, h = player.h;
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(x+2, y+8, w-6, 6);
    // ship body
    ctx.fillStyle = '#49c5b6';
    ctx.beginPath();
    ctx.moveTo(x + w/2, y);
    ctx.lineTo(x + w, y + h);
    ctx.lineTo(x, y + h);
    ctx.closePath();
    ctx.fill();

    // cockpit
    ctx.fillStyle = '#03201a';
    ctx.fillRect(x + w/2 - 6, y + 6, 12, 6);
  }

  function drawInvaders(){
    for(const inv of invaders){
      if(!inv.alive) continue;
      const x = inv.x, y = inv.y, w = inv.w, h = inv.h;
      // body (two-frame simple animation)
      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      const flick = inv.anim;
      // body rectangle
      ctx.fillStyle = '#f9d423';
      ctx.fillRect(-w/2, -h/2, w, h);
      // eyes / details
      ctx.fillStyle = flick ? '#03201a' : '#071829';
      ctx.fillRect(-w/2 + 6, -h/2 + 6, 8, 6);
      ctx.fillRect(w/2 - 14, -h/2 + 6, 8, 6);
      // feet
      ctx.fillRect(-w/2 + 6, h/2 - 6, 6, 4);
      ctx.fillRect(w/2 - 12, h/2 - 6, 6, 4);
      ctx.restore();
    }
  }

  // simple star field
  const stars = [];
  for(let i=0;i<80;i++){
    stars.push({x: Math.random()*canvas.width, y: Math.random()*canvas.height, s: Math.random()*1.6 + 0.3});
  }
  function drawStars(){
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    for(const st of stars) ctx.fillRect(st.x, st.y, st.s, st.s);
  }

  // UI hooks
  startBtn.addEventListener('click', ()=> {
    startGame();
  });
  overlayBtn.addEventListener('click', () => {
    if(overlayTitle.textContent === 'Game Over'){
      restartGame();
      overlay.style.display = 'none';
    } else {
      togglePause();
    }
  });
  toggleSoundBtn.addEventListener('click', () => {
    soundOn = !soundOn;
    toggleSoundBtn.textContent = soundOn ? 'Sound: ON' : 'Sound: OFF';
  });

  // Start with a title overlay
  function showTitle(){
    playing = false;
    paused = true;
    overlay.style.display = 'flex';
    overlayTitle.textContent = 'Space Invaders';
    overlayMsg.textContent = 'Press Start or Space to begin';
    overlayBtn.textContent = 'Start';
  }
  showTitle();

  // Start with space
  window.addEventListener('keydown', (e)=>{
    if(e.key === ' ' && !playing){
      e.preventDefault();
      startGame();
    }
  });

  // Auto-scale canvas pixel size to CSS size for crispness on high-DPI screens
  function resizeCanvasToDisplaySize(){
    const ratio = window.devicePixelRatio || 1;
    const displayWidth = Math.floor(canvas.clientWidth * ratio);
    const displayHeight = Math.floor(canvas.clientHeight * ratio);
    if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
      // Save current objects positions relative to canvas width/height (we keep same logical coordinate system)
      canvas.width = displayWidth;
      canvas.height = displayHeight;
      // scale drawing context
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(ratio, ratio);
    }
  }
  // Call once and on resize
  function setupResize(){
    resizeCanvasToDisplaySize();
    window.addEventListener('resize', resizeCanvasToDisplaySize);
  }
  setupResize();

  </script>
</body>
</html>
